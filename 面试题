1、volatile作用是什么？内存可见性，避免指令重排序。

2、是否有原子性？那一般怎么规避？（锁，atomicxxxx工具类）

3、ConcurerntHashMap为啥比HashTable性能好？

4、switch能否用String？注意点是什么？
答：参数可以是整数表达式，JDK1.5开始支持Enum类，JDK1.7开始支持String。
    当字符串不会频繁改变时可以用枚举来代替String：用Enum.parse。
注意：
1.JDK1.6 的版本中，switch后面的括号里面只能放int类型的值，注意是只能放int类型，但是放byte，short，char类型的也可以。
是因为byte，short，char可以自动提升（自动类型转换）为int。而不能放long型和String型。
JDK1.7 的版本中，switch中可以使用字串String。但仍不支持long型。
2.String时不能传入null作为参数，同时case语句中使用的字符串也不能为null，因为底层是通过equals和hashmap来判断的
hashcode返回的是int型
可以发现：进行switch的实际是hash值，然后用equals进行安全检查（因为hash值可能会发生碰撞），所以性能不如枚举。switch支持String其实是一个语法糖，在编译后的字节码文件中都会被还原成原生类型，并在相应位置插入了强制转换代码，底层的JVM在switch上并没有修改。
当传入switch的是null时，在运行时对一个null调用hashCode()方法，会抛出NullPointerException；如果case写的是null，那么在编译时无法求出hashcode，就会编译报错。
原理：hashCode()+equals() 
编译器在编译期间给代码做了转换。

5、列举final字段初始化地方

6、请列举Http返回码及各自功能。协议怎么支持断点续传？

7、ArrayList LinkList HashMap对比

8、请列举源码中出现的设计模式：单例（都有哪些），builder，策略等

9、view事件冲突解决方案

10、LinearLayout, RelatLayout特点及性能

11、数据持久化都用哪些技术？

12、若用Sqlite问升级怎么做？Rename/删除字段时？

13、sqlite中有需要更新table怎么做？

14、内存泄漏概念，都有哪些行为引起内存泄漏？一般怎么排查？

15、GCRoot?
答：定义：现代虚拟机基本都是采用可达性分析算法来判断对象是否存活，可达性算法的原理是以一系列叫做GC Root的对象为起点出发，引出它们指向的下一个节点，
    再以下个节点为起点，引出此节点指向的下一个结点。这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 GC Root 为起点的引用链中，
    则这些对象会被判断为垃圾对象,会被 GC 回收。
    a, b 对象可回收，就一定会被回收吗?
    并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，
    如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，
    如果不可达，则会被回收，如果可达，则不回收！
    注意： finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!
    GC ROOT有哪此？便于记忆，总结两栈两方法：
    a、虚拟机栈（栈帧中的本地变量表）中引用的对象
    b、本地方法栈中 JNI（即一般说的 Native 方法）引用的对象
    c、方法区中类静态属性引用的对象
    d、方法区中常量引用的对象

16、引用类型
答：除掉这四类八种基本类型，其它的都是对象，也就是引用类型，包括数组。

17、非静态内部类为啥会持有外部类引用
 答：内部类虽然和外部类写在同一个文件中， 但是编译完成后， 还是生成各自的class文件，内部类通过this访问外部类的成员。
 （1）编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象(this)的引用；
 （2）编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为内部类中添加的成员变量赋值；
 （3）在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。
 
18、性能优化都做过哪些？
答：https://juejin.cn/post/6844904105438134286

19、一次完整的HTTP请求过程
答：1.对www.baidu.com这个网址进行DNS域名解析，得到对应的IP地址
　　2.根据这个IP，找到对应的服务器，发起TCP的三次握手
　　3.建立TCP连接后发起HTTP请求
　　4.服务器响应HTTP请求，浏览器得到html代码
　　5.浏览器解析html代码，并请求html代码中的资源（如js、css图片等）（先得到html代码，才能去找这些资源）
　　6.浏览器对页面进行渲染呈现给用户
  
    其中从第三步，建立TCP连接之后，发起HTTP请求
　　HTTP请求报文由三部分组成：请求行，请求头和请求正文
　　请求行：用于描述客户端的请求方式，请求的资源名称以及使用的HTTP协议的版本号（例：GET/books/java.html HTTP/1.1）
　　请求头：用于描述客户端请求哪台主机，以及客户端的一些环境信息等
　　注：这里提一个请求头 Connection，Connection设置为 keep-alive用于说明 客户端这边设置的是，本次HTTP请求之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP建立连接的时间
　　请求正文：当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中（GET方式是保存在url地址后面，不会放到这里）
　　第四步服务器端响应http请求，浏览器得到html代码
　　HTTP响应也由三部分组成：状态码，响应头和实体内容
　　状态码：状态码用于表示服务器对请求的处理结果
　　列举几种常见的：200（没有问题） 302（要你去找别人） 304（要你去拿缓存） 307（要你去拿缓存） 403（有这个资源，但是没有访问权限） 404（服务器没有这个资源） 500（服务器这边有问题）
　　若干响应头：响应头用于描述服务器的基本信息，以及客户端如何处理数据
　　实体内容：服务器返回给客户端的数据
　　注：html资源文件应该不是通过 HTTP响应直接返回去的，应该是通过nginx通过io操作去拿到的吧
https://www.huaweicloud.com/articles/5831df8b6ec4a72385ad339e8c8d43d4.html

20、ANR 产生原理
答：要产生 ANR，至少得有两个输入事件，场景如下：
第一个输入事件产生，系统将其发送给用户当前操作的 App；
系统收到第二个事件，发现当前距第一个输入事件发送时间超过 0.5s 仍未处理完毕，则设置一个定时器，5s 后触发；
5s 之后，若系统发现第一个输入事件仍然没有回应时，则触发 ANR，激活 App 中的 Signal Cather 线程生成 traces.txt，然后弹出 ANR 对话框，告知用户 App 无响应。
也就是说，要产生 ANR，第一个输入事件必需在 5.5s 以上没有被处理完成并反馈回系统；并且要有第二个输入事件产生。
如果没有第二个输入事件，即便第一个输入事件执行了 60s 或更长时间，也是不会产生 ANR 的。
ANR 日志生成原理
系统的 system_server 进程在检测到 App 出现 ANR 后，会向出现 ANR 的进程发送 SIGQUIT (signal 3) 信号。
正常情况下，系统的 libart.so 会收到该信号，并调用 Java 虚拟机的 dump 方法生成 traces。
以友盟+的 U-APM 应用性能监控平台为例，集成SDK 后，SDK 会拦截 SIGQUIT。在出现 ANR 时，libcrashsdk.so 会优先收到信号，并生成 traces 和 ANR 日志。
在 SDK 处理完信号后，会将信号继续传递给系统的 libart.so，让系统生成 ANR traces.txt。

21、深入探索Android稳定性优化
答：https://juejin.cn/post/6844903972587716621

22、使用addr2line分析Crash日志
在NDK开发中经常会出现应用Crash的情况，而JNI层的报错信息，不像Java层报错信息那样可以直接在日志中看到错误的行数，JNI层中出现的错误直接看根本定位不到错误的位置。
通常来说，JNI报的基本都是堆栈信息，需要NDK的一些工具进行地址转换，转换后即可看到错误的位置。这些地址转换的工具有addr2line、ndk-stack等。
原文链接：https://blog.csdn.net/Xiongjiayo/article/details/86514623
答：https://blog.csdn.net/Xiongjiayo/article/details/86514623
https://blog.csdn.net/afei__/article/details/81181827


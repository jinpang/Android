1、volatile作用是什么？内存可见性，避免指令重排序。
2、是否有原子性？那一般怎么规避？（锁，atomicxxxx工具类）
3、ConcurerntHashMap为啥比HashTable性能好？
4、switch能否用String？注意点是什么？
5、列举final字段初始化地方
6、请列举Http返回码及各自功能。协议怎么支持断点续传？
7、ArrayList LinkList HashMap对比
8、请列举源码中出现的设计模式：单例（都有哪些），builder，策略等
9、view事件冲突解决方案
10、LinearLayout, RelatLayout特点及性能
11、数据持久化都用哪些技术？
12、若用Sqlite问升级怎么做？Rename/删除字段时？
13、sqlite中有需要更新table怎么做？
14、内存泄漏概念，都有哪些行为引起内存泄漏？一般怎么排查？
15、GCRoot?
答：定义：现代虚拟机基本都是采用可达性分析算法来判断对象是否存活，可达性算法的原理是以一系列叫做GC Root的对象为起点出发，引出它们指向的下一个节点，
    再以下个节点为起点，引出此节点指向的下一个结点。这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 GC Root 为起点的引用链中，
    则这些对象会被判断为垃圾对象,会被 GC 回收。
    a, b 对象可回收，就一定会被回收吗?
    并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，
    如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，
    如果不可达，则会被回收，如果可达，则不回收！
    注意： finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!
    GC ROOT有哪此？便于记忆，总结两栈两方法：
    a、虚拟机栈（栈帧中的本地变量表）中引用的对象
    b、本地方法栈中 JNI（即一般说的 Native 方法）引用的对象
    c、方法区中类静态属性引用的对象
    d、方法区中常量引用的对象

16、引用类型
17、非静态内部类为啥会持有外部类引用
 答：内部类虽然和外部类写在同一个文件中， 但是编译完成后， 还是生成各自的class文件，内部类通过this访问外部类的成员。
 （1）编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象(this)的引用；
 （2）编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为内部类中添加的成员变量赋值；
 （3）在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。
18、性能优化都做过哪些？
